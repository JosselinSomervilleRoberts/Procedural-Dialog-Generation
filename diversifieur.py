# -*- coding: utf-8 -*-
"""diversifieur.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11t7W3Yq_CmjJPF6BOIuwwbEWl80s0qiV
"""

"""
!pip install verbecc
!pip install google_trans_new
"""

from verbecc import Conjugator
from google_trans_new import google_translator
import language_tool_python
import io
import random

cg = Conjugator(lang='fr')
tool = None
ts = None
syns = {}


  
COURANT = 1
FAMILIER = 2
SOUTENU = 3



def buildSynonyms():
    """
    Construit le dictionnaire "syns" à partir du fichier "synonymes_tries.txt"
    une entrée de syns est sous la forme :
    syns["manger"] = [["bouffer", "brouter"], [60, 40], [FAMILIER, COURANT]]
    On retrouve dans l ordre : les mots, les probabilités, les registres de langue
    """ 
    global syns
    
    f = open("psclib/fichiers_txt/synonymes/synonymes_tries.txt", "r", encoding="ISO-8859-1")
    liste = f.readlines()
    f.close()
    
    for ligne in liste:
        l1 = ligne.replace("\n","").split("=")
        mot = l1[0]
        synonymes = l1[1]
        
        if len(synonymes) == 0:
            pass
        else:
            l2 = synonymes.split("/")
            syns[mot] = [[], [], []]
            for synonyme in l2:
                l3 = synonyme.split(":")
                syns[mot][0].append(str(l3[0]))
                syns[mot][1].append(int(float(l3[1])))
                syns[mot][2].append(int(l3[2]))

    print("Synonymes chargés.")
                

def cong(s, mode, temps, personne):
  """
  Fonction qui conjugue

  Arguments :
  - s: str (verbe à conjuguer)
  - mode: str. ("indicatif", "imperatif", "subjonctif", "conditionnel", ...)
  - temps: str. ("present", "imparfait", "futur", ...)
  - personne: int. (de 1 a 6)

  Renvoie :
  - c: str (verbe conjugué)
  """
  global cg
  conjugation = cg.conjugate(s)
  c = conjugation['moods'][mode][temps][personne-1]
  return c



def get_syn(s, registre=None):
  """
  Fonction qui renvoie des synonymes de s
  - 50% de chance de renvoyer directement s
  - 50% de chance de choisir un synonyme de s dans le dictionnaire "syns"

  Arguments :
  - s: str. (le mot)
  - registre: str ou int ou list de int ou list de str. Liste (ou non) des registres à utiliser.
  Soit en int (COURANT=1, FAMILIER=2, SOUTENU=3), soit en str : ("COURANT", "FAMILIER", "SOUTENU")
  Attention à ne pas utiliser et des int et des str.
  Par défaut les 3 registres sont choisis.

  Renvoie:
  - syn_choisi: str. (Un synonyme choisi aléatoirement)
  """
  global syns
  
  if len(syns) == 0:
    buildSynonyms()
  
  # Si le registre n'est pas précisé, on les prend tous
  if registre is None: registre = [COURANT, FAMILIER, SOUTENU]
  
  # Si on a précisé juste un registre et non une liste de registre, on corrige ça
  if type(registre) == str:
    registre = [COURANT]
    if registre == "FAMILIER": registre = [FAMILIER]
    if registre == "SOUTENU": registre = [SOUTENU]
    if registre == "TOUS" or "ALL": registre = [COURANT, FAMILIER, SOUTENU]
  elif type(registre) == int:
    registre = [registre]
  elif type(registre) == list:
    for i in range(len(registre)):
      if type(registre[i]) == str:
        registre = [COURANT]
        if registre[i] == "FAMILIER": registre[i] = [FAMILIER]
        if registre[i] == "SOUTENU": registre[i] = [SOUTENU]
        

  if not(s in syns.keys()) or random.random() <= 0.5:
      return s
  
  # On vérifie qu'on ne soit pas dans le cas où il existe des synonymes mais pas du bon registre
  continuer = False
  for r in syns[s][2]:
    if r in registre:
      continuer = True

  if not(continuer) : return s

  synonymes = syns[s]
  syn_a_utiliser = [] # On va filtrer "synonymes" pour ne garder que les regiostres à utiliser
  proba_a_utiliser = []
  
  for i in range(len(synonymes[0])):
    if synonymes[2][i] in registre:
      syn_a_utiliser.append(synonymes[0][i])
      proba_a_utiliser.append(synonymes[1][i])
      
  syn_choisi = random.choices(syn_a_utiliser, weights=proba_a_utiliser, k=1)[0]
  return syn_choisi
  



def correct(s, useCorrection=True):
  """
  Fonction qui corrige un morceau de phrase ave le correcteur de OpenOffice
    
    Arguments :
  - s: str. (le mot)

  Renvoie:
  - s2: str. (la correction)
  """
  global tool
  
  # On charge le correcteur s'il n'est pas chargé
  if tool is None and useCorrection:
      tool = language_tool_python.LanguageToolPublicAPI('fr')
  
  if useCorrection:
      return tool.correct(s)
  else:
      return s



def correctOld(s, useTranslation=True):
  """
  Fonction qui corrige un morceau de phrase avec le double traducteur

  Arguments :
  - s: str. (le mot)

  Renvoie:
  - s2: str. (la correction)
  """
  global ts

  if not(useTranslation):
    return s

  s1 = ts.translate(s, lang_src="fr", lang_tgt="en")
  if type(s1) == list: s1 = s1[0]
  s2 = ts.translate(s1, lang_src="en", lang_tgt="fr")
  if type(s2) == list: s2 = s2[0]
  
  return s2



def diversifier(s, useTranslation=True):
  """
  Fonction qui diverifie un morceau de phrase avec le traducteur en apssant aps plusieurs languages

  Arguments :
  - s: str. (l'expression)

  Renvoie:
  - s2: str. (l'expression diversifiée)
  """
  global ts
  
  # On charge le traducteur s'il n'est pas chargé
  if ts is None and useTranslation:
      ts = google_translator()

  if not(useTranslation):
    return s

  l = ["en"] # ["en", "it", "pt", "de"]
  nb_langues = random.randint(1,1) # Nombre de langues intermédiaires

  langues = []
  for i in range(nb_langues):
    index = random.randint(0,len(l)-1)
    langues.append(l[index])
    l = l[:index] + l[index+1:]

  #s2 = ts.translate(s, lang_src="fr", lang_tgt=langues[0])[1]
  s2 = ts.translate(s, lang_tgt=langues[0])
  for i in range(1, len(langues)):
    #s2 = ts.translate(s2, lang_src=langues[i-1], lang_tgt=langues[i])[1]
    s2 = ts.translate(s2, lang_tgt=langues[i])
  #s2 = ts.translate(s2, lang_src=langues[-1], lang_tgt="fr")[1]
  s2 = ts.translate(s2, lang_tgt="fr")
  return s2